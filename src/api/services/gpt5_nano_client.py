"""
GPT-5 Nano ÂÆ¢Êà∂Á´ØÊúçÂãô
Áî®ÊñºËàá OpenAI GPT-5 Nano Ê®°ÂûãÈÄ≤Ë°å‰∫§‰∫í
"""

import os
import json
import logging
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime

try:
    import openai
except ImportError:
    openai = None

from config import settings
from .gpt5_output_schema import get_gpt5_validator, GPT5TagOutputSchema

logger = logging.getLogger(__name__)


class GPT5NanoClient:
    """OpenAI LLM ÂÆ¢Êà∂Á´ØÈ°ûÂà•
    
    ÊîØÊè¥ÁöÑ GPT-5 Á≥ªÂàóÊ®°ÂûãÔºà2025 ÊúÄÊñ∞ÔºâÔºö
    - gpt-5: Ë§áÈõúÊé®ÁêÜ„ÄÅÂª£ÈóäÁöÑ‰∏ñÁïåÁü•Ë≠ò„ÄÅ‰ª£Á¢ºÁπÅÈáçÊàñÂ§öÊ≠•È©ü‰ª£ÁêÜ‰ªªÂãôÔºàÊúÄÂº∑Â§ßÔºâ
    - gpt-5-mini: ÊàêÊú¨ÂÑ™ÂåñÁöÑÊé®ÁêÜÂíåËÅäÂ§©ÔºõÂπ≥Ë°°ÈÄüÂ∫¶„ÄÅÊàêÊú¨ÂíåËÉΩÂäõÔºàÊé®Ëñ¶Ôºâ
    - gpt-5-nano: È´òÈÄöÈáè‰ªªÂãôÔºåÁâπÂà•ÊòØÁ∞°ÂñÆÁöÑÊåá‰ª§ÈÅµÂæ™ÊàñÂàÜÈ°ûÔºàÊúÄÁ∂ìÊøüÔºâ
    
    ÊîØÊè¥ÁöÑ GPT-4 Á≥ªÂàóÊ®°ÂûãÔºö
    - gpt-4o: Â§öÊ®°ÊÖãÊóóËâ¶Ê®°Âûã
    - gpt-4o-mini: Âø´ÈÄüÁ∂ìÊøüÁöÑÊ®°ÂûãÔºàÈªòË™çÔºâ
    
    Ê≥®ÊÑèÔºöGPT-5 Á≥ªÂàó‰∏çÊîØÊåÅ temperature„ÄÅtop_p„ÄÅlogprobs ÂèÉÊï∏
    """
    
    def __init__(self):
        """ÂàùÂßãÂåñ OpenAI ÂÆ¢Êà∂Á´Ø"""
        # ÂæûÈÖçÁΩÆÂ∞çË±°ËÆÄÂèñ
        self.api_key = settings.openai_api_key
        self.model = settings.openai_model
        self.max_tokens = settings.openai_max_tokens
        self.temperature = settings.openai_temperature
        self.timeout = settings.openai_timeout
        self.enabled = settings.enable_openai_integration
        
        # Ê™¢Êü•ÊòØÂê¶ÁÇ∫ GPT-5 Á≥ªÂàó
        self.is_gpt5 = self.model.startswith("gpt-5")
        
        # Ë®òÈåÑÈÖçÁΩÆÁãÄÊÖã
        logger.info("=" * 60)
        logger.info("ü§ñ GPT-5 Nano ÂÆ¢Êà∂Á´ØÂàùÂßãÂåñ")
        logger.info(f"  - API Key Â∑≤Ë®≠ÁΩÆ: {'‚úÖ ÊòØ' if self.api_key else '‚ùå Âê¶'}")
        logger.info(f"  - Ê®°Âûã: {self.model}")
        logger.info(f"  - ÊúÄÂ§ß Tokens: {self.max_tokens}")
        logger.info(f"  - Ë∂ÖÊôÇÊôÇÈñì: {self.timeout}Áßí")
        logger.info(f"  - ÂäüËÉΩÂïüÁî®: {'‚úÖ ÊòØ' if self.enabled else '‚ùå Âê¶'}")
        logger.info(f"  - OpenAI Â∫´: {'‚úÖ Â∑≤ÂÆâË£ù' if openai else '‚ùå Êú™ÂÆâË£ù'}")
        
        # Ë®òÈåÑ‰ΩøÁî®ÁöÑÊ®°ÂûãÈ°ûÂûã
        if self.enabled:
            model_type = "GPT-5 Á≥ªÂàó" if self.is_gpt5 else "GPT-4 Á≥ªÂàó"
            logger.info(f"  - Ê®°ÂûãÈ°ûÂûã: {model_type}")
            if self.is_gpt5:
                logger.info(f"  - Ê≥®ÊÑè: GPT-5 ‰∏çÊîØÊåÅ temperature ÂèÉÊï∏")
        logger.info("=" * 60)
        
        # ÂàùÂßãÂåñ OpenAI ÂÆ¢Êà∂Á´Ø
        if self.api_key and openai:
            try:
                self.client = openai.OpenAI(api_key=self.api_key)
                logger.info("‚úÖ OpenAI ÂÆ¢Êà∂Á´ØÂàùÂßãÂåñÊàêÂäü")
            except Exception as e:
                self.client = None
                logger.error(f"‚ùå OpenAI ÂÆ¢Êà∂Á´ØÂàùÂßãÂåñÂ§±Êïó: {e}")
        else:
            self.client = None
            if not self.api_key:
                logger.warning("‚ö†Ô∏è OpenAI API key Êú™Ë®≠ÁΩÆ (Ë´ãÂú®Áí∞Â¢ÉËÆäÊï∏‰∏≠Ë®≠ÁΩÆ OPENAI_API_KEY)")
            if not openai:
                logger.warning("‚ö†Ô∏è OpenAI library Êú™ÂÆâË£ù (Âü∑Ë°å: pip install openai)")
    
    def is_available(self) -> bool:
        """Ê™¢Êü• GPT-5 Nano ÊòØÂê¶ÂèØÁî®"""
        return (
            self.enabled and 
            self.client is not None and 
            self.api_key is not None
        )
    
    async def generate_tags(
        self, 
        description: str,
        context: Optional[Dict[str, Any]] = None
    ) -> Optional[Dict[str, Any]]:
        """
        ÁîüÊàêÊ®ôÁ±§Êé®Ëñ¶
        
        Args:
            description: Áî®Êà∂ÊèèËø∞
            context: È°çÂ§ñ‰∏ä‰∏ãÊñáË≥áË®ä
            
        Returns:
            Ê®ôÁ±§Êé®Ëñ¶ÁµêÊûúÊàñ None
        """
        logger.info("=" * 60)
        logger.info("üéØ ÈñãÂßã GPT-5 Nano Ê®ôÁ±§ÁîüÊàê")
        logger.info(f"  - ÊèèËø∞: {description[:100]}{'...' if len(description) > 100 else ''}")
        
        # Ê™¢Êü•ÂèØÁî®ÊÄß
        if not self.is_available():
            logger.warning("‚ùå GPT-5 Nano ‰∏çÂèØÁî®Ôºå‰ΩøÁî®ÈôçÁ¥öÊñπÊ°à")
            logger.warning(f"  - Enabled: {self.enabled}")
            logger.warning(f"  - Client: {self.client is not None}")
            logger.warning(f"  - API Key: {self.api_key is not None}")
            
            # ËøîÂõûÈôçÁ¥öÊñπÊ°à
            fallback_result = GPT5TagOutputSchema.create_fallback_response(description)
            logger.info("üîÑ ‰ΩøÁî®ÈôçÁ¥öÊñπÊ°àÂõûÊáâ")
            return fallback_result
        
        try:
            # ÊßãÂª∫Á≥ªÁµ±ÊèêÁ§∫Ë©û
            system_prompt = self._build_system_prompt(context)
            logger.info(f"  - System prompt Èï∑Â∫¶: {len(system_prompt)} Â≠óÁ¨¶")
            
            # ÊßãÂª∫Áî®Êà∂ÊèêÁ§∫Ë©û
            user_prompt = self._build_user_prompt(description, context)
            logger.info(f"  - User prompt Èï∑Â∫¶: {len(user_prompt)} Â≠óÁ¨¶")
            
            # Ë™øÁî® OpenAI API
            logger.info(f"üì° Ë™øÁî® OpenAI API")
            logger.info(f"  - Ê®°Âûã: {self.model}")
            logger.info(f"  - Max tokens: {self.max_tokens}")
            logger.info(f"  - Timeout: {self.timeout}Áßí")
            
            # GPT-5 Á≥ªÂàó‰∏çÊîØÊåÅ temperature ÂèÉÊï∏
            api_params = {
                "model": self.model,
                "messages": [
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                "max_completion_tokens": self.max_tokens,
                "timeout": self.timeout
            }
            
            # Âè™ÊúâÈùû GPT-5 Ê®°ÂûãÊâçÊ∑ªÂä† temperature
            if not self.is_gpt5:
                api_params["temperature"] = self.temperature
                logger.info(f"  - Temperature: {self.temperature}")
            else:
                logger.info(f"  - Temperature: N/A (GPT-5 ‰∏çÊîØÊåÅ)")
            
            # Ë™øÁî® API
            logger.info("‚è≥ Á≠âÂæÖ API ÂõûÊáâ...")
            response = self.client.chat.completions.create(**api_params)
            logger.info("‚úÖ API ÂõûÊáâÊàêÂäü")
            
            # Ëß£ÊûêÂõûÊáâ
            content = response.choices[0].message.content
            logger.info(f"üì¶ ÂõûÊáâÂÖßÂÆπ:")
            logger.info(f"  - Èï∑Â∫¶: {len(content)} Â≠óÁ¨¶")
            logger.info(f"  - Ââç 500 Â≠óÁ¨¶: {content[:500]}")
            
            # Ëß£Êûê JSON ÂõûÊáâ
            result = self._parse_response(content)
            
            if result:
                logger.info("‚úÖ JSON Ëß£ÊûêÊàêÂäü")
                logger.info(f"  - Tags: {result.get('tags', [])[:5]}")
                logger.info(f"  - Confidence: {result.get('confidence', 0)}")
            else:
                logger.error("‚ùå JSON Ëß£ÊûêÂ§±Êïó")
            
            # Ë®òÈåÑ‰ΩøÁî®Èáè
            self._log_usage(response)
            
            logger.info("=" * 60)
            return result
            
        except openai.APIError as e:
            logger.error("=" * 60)
            logger.error(f"‚ùå OpenAI API ÈåØË™§: {e}")
            logger.error(f"  - ÁãÄÊÖãÁ¢º: {e.status_code if hasattr(e, 'status_code') else 'N/A'}")
            logger.error(f"  - ÈåØË™§Ë®äÊÅØ: {str(e)}")
            logger.error("=" * 60)
            return None
        except openai.APIConnectionError as e:
            logger.error("=" * 60)
            logger.error(f"‚ùå OpenAI ÈÄ£Êé•ÈåØË™§: {e}")
            logger.error("  - ÂèØËÉΩÂéüÂõ†:")
            logger.error("    1. Á∂≤Ë∑ØÈÄ£Êé•ÂïèÈ°å")
            logger.error("    2. API ÈáëÈë∞ÁÑ°Êïà")
            logger.error("    3. OpenAI ÊúçÂãôÊö´ÊôÇ‰∏çÂèØÁî®")
            logger.error("=" * 60)
            return None
        except openai.RateLimitError as e:
            logger.error("=" * 60)
            logger.error(f"‚ùå OpenAI ÈÄüÁéáÈôêÂà∂: {e}")
            logger.error("  - Âª∫Ë≠∞: Á®çÂæåÂÜçË©¶ÊàñÂçáÁ¥ö API ÊñπÊ°à")
            logger.error("=" * 60)
            return None
        except Exception as e:
            logger.error("=" * 60)
            logger.error(f"‚ùå GPT-5 Nano Êú™È†êÊúüÁöÑÈåØË™§: {e}", exc_info=True)
            logger.error("=" * 60)
            return None
    
    def _build_system_prompt(self, context: Optional[Dict[str, Any]] = None) -> str:
        """ÊßãÂª∫Á≥ªÁµ±ÊèêÁ§∫Ë©ûÔºàÁµêÊßãÂåñËº∏Âá∫ÁâàÊú¨Ôºâ"""
        base_prompt = """You are an expert AI image generation tag recommendation assistant for Danbooru-style tagging system.

Your task:
1. Analyze the user's description carefully
2. Recommend 5-10 relevant English tags that best match the description
3. Tags should follow Danbooru conventions (e.g., "1girl", "long_hair", "blue_eyes", "school_uniform")
4. Prioritize commonly used and effective tags
5. Include character, appearance, clothing, and scene tags as appropriate

Tag Categories:
- Character count: 1girl, 2girls, solo, multiple_girls
- Physical features: long_hair, short_hair, blue_eyes, blonde_hair
- Clothing: school_uniform, dress, shirt, skirt
- Actions: sitting, standing, smiling, looking_at_viewer
- Scene: outdoors, indoors, city, forest, night, sunset
- Art style: anime_style, realistic, masterpiece, high_quality

CRITICAL: You MUST return a valid JSON object in this EXACT format:
{
    "tags": ["tag1", "tag2", "tag3", "tag4", "tag5"],
    "confidence": 0.85,
    "reasoning": "Brief explanation of why these tags were chosen",
    "categories": ["CHARACTER", "APPEARANCE", "SCENE"]
}

VALIDATION RULES (strictly enforced):
- "tags": Array of 1-15 strings, English only, use underscores for multi-word tags
- "confidence": Number between 0.6 and 0.95
- "reasoning": Non-empty string explaining your choices (max 500 chars)
- "categories": Optional array from: CHARACTER, APPEARANCE, CLOTHING, ACTION, SCENE, STYLE, OBJECT, COMPOSITION, EFFECT
- Return ONLY the JSON object, no other text
- All field names must be exactly as shown above

Examples of valid tags:
- "1girl", "solo", "long_hair", "blue_eyes", "school_uniform"
- "smiling", "looking_at_viewer", "outdoors", "sunset"
- "anime_style", "masterpiece", "high_quality" """
        
        if context:
            context_info = f"\n\nAdditional context: {json.dumps(context, ensure_ascii=False)}"
            base_prompt += context_info
        
        return base_prompt
    
    def _build_user_prompt(self, description: str, context: Optional[Dict[str, Any]] = None) -> str:
        """ÊßãÂª∫Áî®Êà∂ÊèêÁ§∫Ë©û"""
        prompt = f"User Description: \"{description}\"\n\nPlease analyze this description and recommend the most appropriate Danbooru-style tags for AI image generation."
        
        if context and context.get("existing_tags"):
            prompt += f"\n\nExisting tags to consider: {', '.join(context['existing_tags'])}"
        
        if context and context.get("user_preferences"):
            prompt += f"\n\nUser preferences: {context['user_preferences']}"
        
        if context and context.get("style_hint"):
            prompt += f"\n\nStyle hint: {context['style_hint']}"
        
        return prompt
    
    def _parse_response(self, content: str) -> Optional[Dict[str, Any]]:
        """Ëß£Êûê GPT-5 Nano ÂõûÊáâÔºà‰ΩøÁî®ÁµêÊßãÂåñÈ©óË≠âÔºâ"""
        try:
            # ‰ΩøÁî®Êñ∞ÁöÑÁµêÊßãÂåñÈ©óË≠âÁ≥ªÁµ±
            validator = get_gpt5_validator()
            result = validator.validate(content)
            
            # Ê∑ªÂä†È°çÂ§ñÁöÑÂÖÉË≥áÊñô
            result["generated_at"] = datetime.now().isoformat()
            result["source"] = "gpt-5-nano"
            result["validation_method"] = "json_schema_v1"
            
            # Ë®òÈåÑÈ©óË≠âÁµ±Ë®à
            stats = validator.get_stats()
            logger.info(f"üìä È©óË≠âÁµ±Ë®à: ÊàêÂäüÁéá {stats['success_rate']}% ({stats['successful']}/{stats['total_validations']})")
            
            return result
            
        except ValueError as e:
            logger.error(f"‚ùå GPT-5 ÂõûÊáâÈ©óË≠âÂ§±Êïó: {e}")
            logger.error(f"Raw response: {content[:200]}...")
            return None
        except Exception as e:
            logger.error(f"‚ùå Êú™È†êÊúüÁöÑËß£ÊûêÈåØË™§: {e}", exc_info=True)
            return None
    
    def _log_usage(self, response) -> Dict[str, Any]:
        """
        Ë®òÈåÑ API ‰ΩøÁî®Èáè‰∏¶Ë®àÁÆóÊàêÊú¨
        
        GPT-5 Nano ÂÆöÂÉπ (2025 ÊúÄÊñ∞):
        - Input: $0.00002 / 1K tokens
        - Output: $0.00008 / 1K tokens
        
        Returns:
            ‰ΩøÁî®ÈáèÁµ±Ë®àÂ≠óÂÖ∏
        """
        usage_stats = {
            "prompt_tokens": 0,
            "completion_tokens": 0,
            "total_tokens": 0,
            "estimated_cost_usd": 0.0,
            "model": self.model
        }
        
        try:
            if hasattr(response, 'usage') and response.usage:
                usage = response.usage
                usage_stats["prompt_tokens"] = usage.prompt_tokens
                usage_stats["completion_tokens"] = usage.completion_tokens
                usage_stats["total_tokens"] = usage.total_tokens
                
                # Ê†πÊìöÊ®°ÂûãË®àÁÆóÂØ¶ÈöõÊàêÊú¨
                if self.model == "gpt-5-nano":
                    # GPT-5 Nano ÂÆöÂÉπ
                    input_cost = (usage.prompt_tokens / 1000) * 0.00002
                    output_cost = (usage.completion_tokens / 1000) * 0.00008
                elif self.model == "gpt-5-mini":
                    # GPT-5 Mini ÂÆöÂÉπÔºàÈ†ê‰º∞Ôºâ
                    input_cost = (usage.prompt_tokens / 1000) * 0.00005
                    output_cost = (usage.completion_tokens / 1000) * 0.0002
                elif self.model.startswith("gpt-4"):
                    # GPT-4 Á≥ªÂàóÂÆöÂÉπÔºàÈ†ê‰º∞Ôºâ
                    input_cost = (usage.prompt_tokens / 1000) * 0.00015
                    output_cost = (usage.completion_tokens / 1000) * 0.0006
                else:
                    # ÈªòË™ç‰ΩøÁî® GPT-5 Nano ÂÉπÊ†º
                    input_cost = (usage.prompt_tokens / 1000) * 0.00002
                    output_cost = (usage.completion_tokens / 1000) * 0.00008
                
                total_cost = input_cost + output_cost
                usage_stats["estimated_cost_usd"] = total_cost
                usage_stats["input_cost_usd"] = input_cost
                usage_stats["output_cost_usd"] = output_cost
                
                logger.info("üí∞ API ‰ΩøÁî®ÈáèÁµ±Ë®à:")
                logger.info(f"  - Prompt tokens: {usage.prompt_tokens}")
                logger.info(f"  - Completion tokens: {usage.completion_tokens}")
                logger.info(f"  - Total tokens: {usage.total_tokens}")
                logger.info(f"  - Input cost: ${input_cost:.6f}")
                logger.info(f"  - Output cost: ${output_cost:.6f}")
                logger.info(f"  - Total cost: ${total_cost:.6f} USD")
                
                # Ë®àÁÆóÊØèÊúàÊàêÊú¨È†ê‰º∞
                monthly_estimate_1k = total_cost * 1000
                monthly_estimate_10k = total_cost * 10000
                logger.info(f"  - ÊúàÂ∫¶ÊàêÊú¨È†ê‰º∞:")
                logger.info(f"    ‚Ä¢ 1,000 Ê¨°Ë™øÁî®: ${monthly_estimate_1k:.2f}")
                logger.info(f"    ‚Ä¢ 10,000 Ê¨°Ë™øÁî®: ${monthly_estimate_10k:.2f}")
                
        except Exception as e:
            logger.error(f"Failed to log usage: {e}")
        
        return usage_stats
    
    async def test_connection(self) -> Dict[str, Any]:
        """Ê∏¨Ë©¶ GPT-5 Nano ÈÄ£Êé•"""
        test_result = {
            "available": False,
            "error": None,
            "config": {},
            "test_response": None,
            "validation_stats": None
        }
        
        try:
            # Ê™¢Êü•ÈÖçÁΩÆ
            test_result["config"] = {
                "api_key_set": bool(self.api_key),
                "model": self.model,
                "max_tokens": self.max_tokens,
                "temperature": self.temperature,
                "timeout": self.timeout,
                "enabled": self.enabled
            }
            
            # Áç≤ÂèñÈ©óË≠âÁµ±Ë®à
            validator = get_gpt5_validator()
            test_result["validation_stats"] = validator.get_stats()
            
            if not self.is_available():
                test_result["error"] = "GPT-5 Nano not available"
                return test_result
            
            # Ê∏¨Ë©¶ API Ë™øÁî®
            test_params = {
                "model": self.model,
                "messages": [
                    {"role": "system", "content": "‰Ω†ÊòØ‰∏ÄÂÄãÊ∏¨Ë©¶Âä©Êâã„ÄÇË´ãÂõûÊáâ 'Hello, OpenAI!'"},
                    {"role": "user", "content": "Ë´ãÂõûÊáâÊ∏¨Ë©¶Ë®äÊÅØ"}
                ],
                "max_completion_tokens": 50,
                "timeout": 10
            }
            
            # Âè™ÊúâÈùû GPT-5 Ê®°ÂûãÊâçÊ∑ªÂä† temperature
            if not self.is_gpt5:
                test_params["temperature"] = 0.1
            
            test_response = self.client.chat.completions.create(**test_params)
            
            test_result["available"] = True
            test_result["test_response"] = test_response.choices[0].message.content
            
        except Exception as e:
            test_result["error"] = str(e)
            logger.error(f"GPT-5 Nano connection test failed: {e}")
        
        return test_result
    
    def get_validation_stats(self) -> Dict[str, Any]:
        """Áç≤ÂèñÈ©óË≠âÁµ±Ë®à‰ø°ÊÅØ"""
        validator = get_gpt5_validator()
        return validator.get_stats()
    
    def reset_validation_stats(self) -> None:
        """ÈáçÁΩÆÈ©óË≠âÁµ±Ë®à"""
        validator = get_gpt5_validator()
        validator.reset_stats()


# ÂÖ®ÂüüÂØ¶‰æã
_gpt5_nano_client = None


def get_gpt5_nano_client() -> GPT5NanoClient:
    """Áç≤Âèñ GPT-5 Nano ÂÆ¢Êà∂Á´ØÂØ¶‰æã"""
    global _gpt5_nano_client
    if _gpt5_nano_client is None:
        _gpt5_nano_client = GPT5NanoClient()
    return _gpt5_nano_client
